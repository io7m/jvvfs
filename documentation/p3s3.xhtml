<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jvvfs 4.0.1 Documentation: 3.3. Virtual paths</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jvvfs/">io7m-jvvfs</a> 4.0.1
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">3.2. Names</td><td class="st200_navbar_up_title_cell">3. Semantics</td><td class="st200_navbar_next_title_cell">3.4. Archives</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p3s2.xhtml#st200_p3s2">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s4.xhtml#st200_p3s4">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p3s3" href="#st200_p3s3">3.3</a></div><div class="st200_section_title">Virtual paths</div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s3ss1" href="#st200_p3s3ss1">3.3.1</a></div><div class="st200_subsection_title">Semantics</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss1pg1" href="#st200_p3s3ss1pg1">1</a></div><div class="st200_paragraph">
      Virtual paths in <span class="st200_term package">jvvfs</span> are conceptually
      a list of <a class="st200_link" href="p3s2.xhtml#st200_p3s2">names</a>,
      with the empty list representing the root.
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss1fo1" href="#st200_p3s3ss1fo1">3.3.1.1. Virtual path type</a></div><pre class="st200_verbatim">Definition path_virtual :=
  list {n : name | name_valid n}.

Definition root : path_virtual :=
  nil.
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss1pg2" href="#st200_p3s3ss1pg2">2</a></div><div class="st200_paragraph">
          A path <span class="st200_term variable">p0</span> is an ancestor of
          <span class="st200_term variable">p1</span> iff
          <span class="st200_term variable">p0</span> is a prefix of
          <span class="st200_term variable">p1</span> (that is, the first <span class="st200_term expression">length p0</span>
          elements of <span class="st200_term variable">p1</span> are equal to
          <span class="st200_term variable">p0</span>), but
          <span class="st200_term expression">p0 ≠ p1</span>.
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss1fo2" href="#st200_p3s3ss1fo2">3.3.1.2. Virtual path ancestor</a></div><pre class="st200_verbatim">Require Coq.Lists.List.

Definition is_prefix (p0 p1 : path_virtual) :=
  List.firstn (length p0) p1 = p0.

Definition is_ancestor_of (p0 p1 : path_virtual) :=
  p0 &lt;&gt; p1 /\ is_prefix p0 p1.
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss1pg3" href="#st200_p3s3ss1pg3">3</a></div><div class="st200_paragraph">
          Consequently, a path <span class="st200_term variable">p0</span> is the parent of
          <span class="st200_term variable">p1</span> iff
          <span class="st200_term variable">p0</span> is an ancestor of
          <span class="st200_term variable">p1</span> and <span class="st200_term expression">∃n. app p0 n = p1</span>
          (where <span class="st200_term function">app</span> is the standard list append function).
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss1fo3" href="#st200_p3s3ss1fo3">3.3.1.3. Virtual path parent</a></div><pre class="st200_verbatim">Require Coq.Lists.List.

Definition is_parent_of (p0 p1 : path_virtual) :=
  is_ancestor_of p0 p1 /\ exists n, app p0 (n :: nil) = p1.
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss1pg4" href="#st200_p3s3ss1pg4">4</a></div><div class="st200_paragraph">
          Iff <span class="st200_term variable">p1</span> is an ancestor of
          <span class="st200_term variable">p0</span>, or <span class="st200_term expression">p0 = p1</span>,
          the <span class="st200_term function">subtraction</span> of
          <span class="st200_term variable">p1</span> from
          <span class="st200_term variable">p0</span> is defined as the removal of the
          first <span class="st200_term expression">length p1</span> elements of
          <span class="st200_term variable">p0</span>.
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss1fo4" href="#st200_p3s3ss1fo4">3.3.1.4. Virtual path subtraction</a></div><pre class="st200_verbatim">Require Coq.Lists.List.

Definition subtract
  (p0 p1 : path_virtual)
  (_     : is_ancestor_of p1 p0 \/ p0 = p1) :=
  List.skipn (length p1) p0.
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss1pg5" href="#st200_p3s3ss1pg5">5</a></div><div class="st200_paragraph">
          It naturally follows that it is possible to obtain a list
          of all ancestors of a path <span class="st200_term variable">p</span>
          by successively concatenating the elements of
          <span class="st200_term variable">p</span> to the root, minus the last element.
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss1fo5" href="#st200_p3s3ss1fo5">3.3.1.5. Virtual path ancestors</a></div><pre class="st200_verbatim">Require Coq.Lists.List.

Fixpoint ancestors_including_self (p : path_virtual) : list path_virtual :=
  cons root (match p with
    | nil       =&gt; nil
    | cons y ys =&gt; List.map (cons y) (ancestors_including_self ys)
    end).

Definition ancestors (p : path_virtual) : list path_virtual :=
  List.removelast (ancestors_including_self p).
</pre></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s3ss2" href="#st200_p3s3ss2">3.3.2</a></div><div class="st200_subsection_title">Syntax</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss2pg1" href="#st200_p3s3ss2pg1">1</a></div><div class="st200_paragraph">
          The concrete syntax of virtual paths is given by the following
          EBNF <span class="st200_footnote_reference"><a id="st200_fn_5_ref" href="#st200_fn_5">[5]</a></span> grammar:
        </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s3ss2fo1" href="#st200_p3s3ss2fo1">3.3.2.1. Virtual path EBNF</a></div><pre class="st200_verbatim">path = "/" , [ name , ("/" , name)* ] ;</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s3ss2pg2" href="#st200_p3s3ss2pg2">2</a></div><div class="st200_paragraph">
          Where <span class="st200_term variable">name</span> represents a valid
          <a class="st200_link" href="p3s2.xhtml#st200_p3s2">name</a>.
        </div></div></div></div><div class="st200_footnotes"><hr/><div class="st200_footnote_container"><div class="st200_footnote_number">[<a id="st200_fn_5" href="#st200_fn_5_ref">5</a>]</div><div class="st200_footnote_body">
            <a class="st200_link_external" href="http://en.wikipedia.org/wiki/EBNF">http://en.wikipedia.org/wiki/EBNF</a>
          </div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p3s2.xhtml#st200_p3s2">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s4.xhtml#st200_p3s4">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">3.2. Names</td><td class="st200_navbar_up_title_cell">3. Semantics</td><td class="st200_navbar_next_title_cell">3.4. Archives</td></tr></table></div></div></body></html>
