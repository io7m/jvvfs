<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2013 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jvvfs 3.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />

    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jvvfs</s:term>
          package implements a pseudo virtual filesystem abstraction. The
          package essentially constructs a unified namespace from sets of
          mounted archives (such as directories, zip files, etc). It is
          inspired by
          <s:link-external target="http://icculus.org/physfs">PhysicsFS</s:link-external>
          but does not contain support for old proprietary/obscure archive
          formats.
        </s:paragraph>
        <s:paragraph>
          When using a filesystem abstraction such as
          <s:term type="package">jvvfs</s:term>, it becomes very easy
          for application developers to distribute updates. The developer
          initially distributes the program resources (images, audio, etc)
          as one or more zip archives. Updates to the program data then consist
          of zip archives containing only files that have been changed: these
          new archives are simply mounted over the top of the old ones
          in the virtual filesystem.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          The package is written in pure Java and is expected to work
          in any environment supporting Java 6.
        </s:paragraph>
        <s:paragraph>
          The filesystem abstraction allows developers to access program
          resources using platform-independent notation. The package is
          carefully written to ensure that applications access resources
          consistently across all platforms (including consistency under
          erroneous conditions).
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external target="http://search.maven.org/#search|ga|1|io7m-jvvfs">Central Repository</s:link-external>,
          so it's possible to use the <s:term type="package">jvvfs</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jvvfs</groupId>
  <artifactId>io7m-jvvfs</artifactId>
  <version>[3.0.0, 4.0.0)</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          All <s:link-external target="http://io7m.com">io7m.com</s:link-external>
          packages use Semantic Versioning <s:footnote>
          	<s:link-external target="http://semver.org">http://semver.org</s:link-external>
          </s:footnote>, which implies that it is always safe to use version ranges
          with an exclusive upper bound equal to the next major version - the API of
          the package will not change in a backwards-incompatible manner before the
          next major version.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        This release of the software passed 100% of the included unit tests on
        the following platforms:
      </s:paragraph>
      <s:formal-item kind="platform_table" type="platforms">
        <s:formal-item-title>Supported systems</s:formal-item-title>
        <s:table>
          <s:table-summary>Supported systems</s:table-summary>
          <s:table-head>
            <s:table-column-name>OS</s:table-column-name>
            <s:table-column-name>OS-Version</s:table-column-name>
            <s:table-column-name>OS-Arch</s:table-column-name>
            <s:table-column-name>JDK-Vendor</s:table-column-name>
            <s:table-column-name>JDK-Version</s:table-column-name>
            <s:table-column-name>VM</s:table-column-name>
            <s:table-column-name>VM-Version</s:table-column-name>
          </s:table-head>
          <s:table-body>
<s:table-row xmlns:s="http://www.io7m.com/schemas/structural/1.0.0">
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.8.4-1-ARCH</s:table-cell>
  <s:table-cell>amd64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_17</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.7-b01</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>FreeBSD</s:table-cell>
  <s:table-cell>9.0-RELEASE</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>21.0-b17</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Mac OS X</s:table-cell>
  <s:table-cell>10.6.8</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>1.6.0_31</s:table-cell>
  <s:table-cell>Java HotSpot(TM) 64-Bit Server VM</s:table-cell>
  <s:table-cell>20.6-b01-413</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>SunOS</s:table-cell>
  <s:table-cell>5.11</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_21</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>17.0-b16</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Windows XP</s:table-cell>
  <s:table-cell>5.1</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_09</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.5-b02</s:table-cell>
</s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jvvfs</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright © 2013 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>User Manual</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:subsection xml:id="com.io7m.jvvfs.usage.filesystem">
      	<s:subsection-title>Filesystem</s:subsection-title>
        <s:paragraph>
      	  The <s:term type="package">jvvfs</s:term> package presents
          a virtual <s:term>filesystem</s:term> in which
          <s:link target="com.io7m.jvvfs.usage.archives">archives</s:link> are
          <s:link target="com.io7m.jvvfs.usage.mounting">mounted</s:link> to
          form a unified namespace. This filesystem is conceptually
          and practically distinct from the filesystem
          presented by the operating system. The
          <s:term type="package">jvvfs</s:term> package never writes to
          or otherwise modifies the operating system filesystem in any
          way.
        </s:paragraph>
        <s:paragraph>
          The <s:term type="package">jvvfs</s:term> virtual <s:term>filesystem</s:term>
          presents a hierarchical directory system very similar to the typical
          UNIX filesystem, supporting a subset of the normal UNIX filesystem operations
          such as retrieving the modification time of a file, retrieving the
          size of a file in bytes, listing the contents of a directory,
          and opening a file as a stream of bytes.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jvvfs.usage.archives">
      	<s:subsection-title>Archives</s:subsection-title>
        <s:paragraph>
	      An <s:term>archive</s:term> is a file or directory in the
	      operating system that can be
	      <s:link target="com.io7m.jvvfs.usage.mounting">mounted</s:link>.
	      The <s:term type="package">jvvfs</s:term> package currently
	      supports mounting operating system
	      <s:term>directories</s:term> and
	      <s:term>zip</s:term>
	      <s:footnote>
	        <s:link-external target="http://en.wikipedia.org/wiki/Zip_(file_format)">http://en.wikipedia.org/wiki/Zip_(file_format)</s:link-external>
	      </s:footnote>
	      files.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jvvfs.usage.mounting">
      	<s:subsection-title>Mounting</s:subsection-title>
      	<s:paragraph>
      	  Mounting an <s:link target="com.io7m.jvvfs.usage.archives">archive</s:link>
      	  makes the contents of that archive accessible in the filesystem.
      	</s:paragraph>
      	<s:paragraph>
          If an <s:link target="com.io7m.jvvfs.usage.archives">archive</s:link>
          is <s:term>mounted</s:term> at a directory
          <s:term type="variable">/M</s:term>, and the archive
          contains a file or directory named <s:term type="variable">F</s:term>,
          then that file or directory is accessible in the
          virtual
          <s:link target="com.io7m.jvvfs.usage.filesystem">filesystem</s:link>
          at <s:term type="variable">/M/F</s:term>. As mentioned, directories
          can be arbitrarily nested, and archives can be mounted at any
          directory in the filesystem.
      	</s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jvvfs.usage.capabilities">
      	<s:subsection-title>Capabilities</s:subsection-title>
      	<s:paragraph>
	      The set of operations that can be performed on the virtual
	      <s:link target="com.io7m.jvvfs.usage.filesystem">filesystem</s:link>
	      is divided into <s:term>capabilities</s:term>. The purpose of this
	      is to allow code to be separated according to the principle of
	      least privilege. That is, if a given function only needs to read
	      from the filesystem and does not need to be able to mount or unmount
	      archives, then it can be declared as taking a value of type
	      <s:link-external target="javadoc/com/io7m/jvvfs/FSCapabilityRead.html">FSCapabilityRead</s:link-external>
	      as opposed to, for example, a value of type
	      <s:link-external target="javadoc/com/io7m/jvvfs/Filesystem.html">Filesystem</s:link-external>.
	      This allows the type system to give much stronger guarantees about
	      what a particular function can do to the filesystem.
      	</s:paragraph>
      	<s:paragraph>
          See the JavaDoc documentation for
          <s:link-external target="javadoc/com/io7m/jvvfs/FSCapabilityAll.html">FSCapabilityAll</s:link-external>
          for the definitions of the capabilities.
      	</s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Tutorial</s:section-title>
      <s:paragraph>
        First, the filesystem is created by specifying an
        <s:term type="term">archive directory</s:term> containing archives
        (zip files, directories, etc):
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Filesystem creation</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathReal path = new PathReal("/path/to/application/resources");
final Filesystem fs = Filesystem.makeWithArchiveDirectory(log, path);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Then, individual archives can be mounted into the filesystem
        in much the same way as disks are mounted in the UNIX filesystem.
        All archives are treated in a read-only manner. The
        <s:term type="package">jvvfs</s:term> package never writes to the
        filesystem or any archives.
      </s:paragraph>
      <s:paragraph>
        Values of type <s:term type="type">PathReal</s:term> denote
        platform-specific paths (and should therefore be given in
        platform-specific notation). Use of
        <s:term type="constant">File.separatorChar</s:term> in the Java
        standard library is recommended.
      </s:paragraph>
      <s:paragraph>
        Assuming <s:term type="file">archive.zip</s:term> exists in the
        specified archive directory, the archive can be mounted in the
        root directory of the virtual filesystem:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Mounting archives</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathVirtual mount = PathVirtual.ofString("/");
fs.mountArchive("archive.zip", mount);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Values of type <s:term type="type">PathVirtual</s:term> denote
        paths in the virtual filesystem and are given in platform-independent
        notation. Virtual path components are separated by
        <s:term type="constant">/</s:term> and must always begin with
        a leading <s:term type="constant">/</s:term> (the paths must always
        be absolute). The filesystem currently has no concept of a "current
        working directory", so relative paths have no meaning.
      </s:paragraph>
      <s:paragraph>
        Assuming <s:term type="file">archive.zip</s:term> contains the
        file <s:term type="file">/a/b/c/file.txt</s:term>, the file can
        be opened, unsurprisingly, by the path
        <s:term type="file">/a/b/c/file.txt</s:term>:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Opening a file</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathVirthal path   = PathVirtual.ofString("/a/b/c/file.txt");
final InputStream stream = fs.openFile(path);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        It is possible to mount archives at directories other than the
        root. It is possible to create directories in the virtual filesystem
        with the
       	<s:link-external target="javadoc/com/io7m/jvvfs/FSCapabilityCreateDirectory#createDirectory(com.io7m.jvvfs.PathVirtual)">createDirectory</s:link-external>
       	function, if no currently mounted archive provides the desired
       	mount point. Manually created directories are purely virtual constructs;
        creating a directory via the <s:term type="package">jvvfs</s:term>
        API does not modify the real OS filesystem or any archives.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Creating a directory</s:formal-item-title>
        <s:verbatim><![CDATA[
// If "archive1.zip" contains "/a/b/file.txt", then "archive2.zip" could, for
// example, be mounted at "/a" or "/a/b".
fs.mount("archive1.zip", PathVirtual.ROOT);
assert fs.isDirectory(PathVirtual.ofString("/a"));
assert fs.isDirectory(PathVirtual.ofString("/a/b"));
fs.mount("archive2.zip", PathVirtual.ofString("/a"));

// Explicitly creating "/c" and mounting "archive2.zip" there is also a possibility.
fs.createDirectory(PathVirtual.ofString("/c"));
assert fs.isDirectory(PathVirtual.ofString("/c"));
fs.mount("archive2.zip", PathVirtual.ofString("/c"));

// Assuming "/xyz/file.txt" exists in "archive2.zip", both of the following will work:
final InputStream s0 = fs.openFile("/a/xyz/file.txt");
final InputStream s1 = fs.openFile("/c/xyz/file.txt");]]>
        </s:verbatim>
      </s:formal-item>
    </s:section>
    
    <s:section>
      <s:section-title>The Jvvfs Shell</s:section-title>
	  <s:subsection>
	  	<s:subsection-title>Overview</s:subsection-title>
	  	<s:paragraph>
      	  The <s:term type="package">jvvfs</s:term> package includes a simple
      	  command-line shell program for manipulating and exploring
      	  <s:term type="package">jvvfs</s:term> filesystems.
        </s:paragraph>
        <s:paragraph>
          The program is distributed as part of the
          <s:term type="package">io7m-jvvfs-shell</s:term> package, with the
          <s:term type="function">main</s:term> program provided in the
          <s:link-external target="javadoc/com/io7m/jvvfs/shell/Shell.html">Shell</s:link-external>
          class.
        </s:paragraph>
	  	<s:paragraph>
	  	  The program takes a pair of arguments: The name of a configuration
	  	  file, and the name of a directory containing archive files.
	  	</s:paragraph>
	  </s:subsection>
	  <s:subsection>
	  	<s:subsection-title>shell.conf</s:subsection-title>
	  	<s:paragraph>
	      The sole purpose of the configuration file, at present, is to
	      control logging. The <s:term type="package">jvvfs</s:term> package
	      uses <s:term type="package">jlog</s:term>
	      <s:link-external target="http://io7m.com/software/jlog">http://io7m.com/software/jlog</s:link-external>
	      internally for extremely fine-grained control of logging. All logging
	      controls for <s:term type="package">jvvfs</s:term> are given the prefix
	      <s:term type="constant">com.io7m.jvvfs</s:term>. A trivial configuration
	      file that only logs errors is sufficient for almost all users:
	  	</s:paragraph>
	  	<s:formal-item>
	  	  <s:formal-item-title>Example shell.conf</s:formal-item-title>
	  	  <s:verbatim><![CDATA[
com.io7m.jvvfs.logs.shell = true
com.io7m.jvvfs.level      = LOG_ERROR]]>
	  	  </s:verbatim>
	  	</s:formal-item>
	  </s:subsection>
	  <s:subsection>
	    <s:subsection-title>Commands</s:subsection-title>
	    <s:paragraph>
		  Usage information on shell commands can be obtained from the
		  <s:term type="function">help</s:term> command. The shell supports
		  tab-completion
		  <s:footnote>
		  	<s:link-external target="http://en.wikipedia.org/wiki/Command_line_completion">http://en.wikipedia.org/wiki/Command_line_completion</s:link-external>
		  </s:footnote> for commands.
	  	</s:paragraph>
	  	<s:paragraph>
	  	  A transcript of an example session showing some of the features
	  	  of the shell is as follows:
	  	</s:paragraph>
	  	<s:formal-item>
	  	  <s:formal-item-title>Example session</s:formal-item-title>
	  	  <s:verbatim><![CDATA[

]]>
	  	  </s:verbatim>
	  	</s:formal-item>
	  </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Semantics</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Virtual paths</s:section-title>
      <s:paragraph>
      	The syntax and semantics of virtual paths.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Archives</s:section-title>
      <s:paragraph>
      	The semantics of archives.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Filesystem</s:section-title>
      <s:paragraph>
      	The semantics of the filesystem.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Rationale</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Why not Java resources?</s:section-title>
      <s:paragraph>
        Java resources allow developers to access program resources and
        data files without explicit access to a filesystem. This is usually
        sufficient if all the resources in question are conceptually part of
        the program. The main problem that <s:term type="package">jvvfs</s:term>
        attempts to solve is the problem of the set of required resources not
        being known or available on program startup.
      </s:paragraph>
      <s:paragraph>
        Consider a game or simulation that allows the loading of third-party
        levels or other assets. The <s:link-external target="http://openttd.org">OpenTTD</s:link-external>
        engine is a good example of this, as it comes with a built-in installer
        for third party content:
      </s:paragraph>
      <s:formal-item kind="illustration">
        <s:formal-item-title>OpenTTD content installer</s:formal-item-title>
        <s:image source="openttd_content.png">OpenTTD content installer</s:image>
      </s:formal-item>
      <s:paragraph>
        Implementing the above with Java resources turns out to be rather
        complicated. Overriding resources (to allow for content "upgrades")
        is equally difficult.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="package">jvvfs</s:term> package provides a uniform
        namespace for all resources, and new resources can be added at any time
        by simply adding new archives and/or directories to the
        <s:term type="term">archive directory</s:term> and then mounting them
        as explained elsewhere in this documentation. The actual downloading of
        external resource archives is considered to be outside of the scope of
        <s:term type="package">jvvfs</s:term> and can be easily provided by
        classes in the Java standard library.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
