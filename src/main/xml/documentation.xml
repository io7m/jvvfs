<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2013 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jvvfs 3.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />

    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jvvfs</s:term>
          package implements a pseudo virtual filesystem abstraction. The
          package essentially constructs a unified namespace from sets of
          mounted archives (such as directories, zip files, etc). It is
          inspired by
          <s:link-external target="http://icculus.org/physfs">PhysicsFS</s:link-external>
          but does not contain support for old proprietary/obscure archive
          formats.
        </s:paragraph>
        <s:paragraph>
          When using a filesystem abstraction such as
          <s:term type="package">jvvfs</s:term>, it becomes very easy
          for application developers to distribute updates. The developer
          initially distributes the program resources (images, audio, etc)
          as one or more zip archives. Updates to the program data then consist
          of zip archives containing only files that have been changed: these
          new archives are simply mounted over the top of the old ones
          in the virtual filesystem.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          The package is written in pure Java and is expected to work
          in any environment supporting Java 6.
        </s:paragraph>
        <s:paragraph>
          The filesystem abstraction allows developers to access program
          resources using platform-independent notation. The package is
          carefully written to ensure that applications access resources
          consistently across all platforms (including consistency under
          erroneous conditions).
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external target="http://search.maven.org/#search|ga|1|io7m-jvvfs">Central Repository</s:link-external>,
          so it's possible to use the <s:term type="package">jvvfs</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jvvfs</groupId>
  <artifactId>io7m-jvvfs</artifactId>
  <version>[3.0.0, 4.0.0)</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          All <s:link-external target="http://io7m.com">io7m.com</s:link-external>
          packages use Semantic Versioning <s:footnote>
          	<s:link-external target="http://semver.org">http://semver.org</s:link-external>
          </s:footnote>, which implies that it is always safe to use version ranges
          with an exclusive upper bound equal to the next major version - the API of
          the package will not change in a backwards-incompatible manner before the
          next major version.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        This release of the software passed 100% of the included unit tests on
        the following platforms:
      </s:paragraph>
      <s:formal-item kind="platform_table" type="platforms">
        <s:formal-item-title>Supported systems</s:formal-item-title>
        <s:table>
          <s:table-summary>Supported systems</s:table-summary>
          <s:table-head>
            <s:table-column-name>OS</s:table-column-name>
            <s:table-column-name>OS-Version</s:table-column-name>
            <s:table-column-name>OS-Arch</s:table-column-name>
            <s:table-column-name>JDK-Vendor</s:table-column-name>
            <s:table-column-name>JDK-Version</s:table-column-name>
            <s:table-column-name>VM</s:table-column-name>
            <s:table-column-name>VM-Version</s:table-column-name>
          </s:table-head>
          <s:table-body>
<s:table-row xmlns:s="http://www.io7m.com/schemas/structural/1.0.0">
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.8.4-1-ARCH</s:table-cell>
  <s:table-cell>amd64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_17</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.7-b01</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>FreeBSD</s:table-cell>
  <s:table-cell>9.0-RELEASE</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>21.0-b17</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Mac OS X</s:table-cell>
  <s:table-cell>10.6.8</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>1.6.0_31</s:table-cell>
  <s:table-cell>Java HotSpot(TM) 64-Bit Server VM</s:table-cell>
  <s:table-cell>20.6-b01-413</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>SunOS</s:table-cell>
  <s:table-cell>5.11</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_21</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>17.0-b16</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Windows XP</s:table-cell>
  <s:table-cell>5.1</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_09</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.5-b02</s:table-cell>
</s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jvvfs</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright © 2013 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Tutorial</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Tutorial</s:section-title>
      <s:paragraph>
        The <s:term type="package">jvvfs</s:term> package arbitrates
        access to a set of <s:term>archives</s:term> by presenting a
        unified namespace similar to the UNIX "virtual filesystem".
      </s:paragraph>
      <s:paragraph>
        First, the filesystem is created by specifying an
        <s:term type="term">archive directory</s:term> containing archives
        (zip files, directories, etc):
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Filesystem creation</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathReal path = new PathReal("/path/to/application/resources");
final Filesystem fs = Filesystem.makeWithArchiveDirectory(log, path);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Then, individual archives can be mounted into the filesystem
        in much the same way as disks are mounted in the UNIX filesystem.
        All archives are treated in a read-only manner. The
        <s:term type="package">jvvfs</s:term> package never writes to the
        filesystem or any archives.
      </s:paragraph>
      <s:paragraph>
        Values of type <s:term type="type">PathReal</s:term> denote
        platform-specific paths (and should therefore be given in
        platform-specific notation). Use of
        <s:term type="constant">File.separatorChar</s:term> in the Java
        standard library is recommended.
      </s:paragraph>
      <s:paragraph>
        Assuming <s:term type="file">archive.zip</s:term> exists in the
        specified archive directory, the archive can be mounted in the
        root directory of the virtual filesystem:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Mounting archives</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathVirtual mount = PathVirtual.ofString("/");
fs.mountArchive("archive.zip", mount);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Values of type <s:term type="type">PathVirtual</s:term> denote
        paths in the virtual filesystem and are given in platform-independent
        notation. Virtual path components are separated by
        <s:term type="constant">/</s:term> and must always begin with
        a leading <s:term type="constant">/</s:term> (the paths must always
        be absolute). The filesystem currently has no concept of a "current
        working directory", so relative paths have no meaning.
      </s:paragraph>
      <s:paragraph>
        Assuming <s:term type="file">archive.zip</s:term> contains the
        file <s:term type="file">/a/b/c/file.txt</s:term>, the file can
        be opened, unsurprisingly, by the path
        <s:term type="file">/a/b/c/file.txt</s:term>:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Opening a file</s:formal-item-title>
        <s:verbatim><![CDATA[
final PathVirthal path   = PathVirtual.ofString("/a/b/c/file.txt");
final InputStream stream = fs.openFile(path);]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        It is possible to mount archives at directories other than the
        root. It is possible to create directories in the virtual filesystem
        with the
       	<s:link-external target="javadoc/com/io7m/jvvfs/FSCapabilityCreateDirectory#createDirectory(com.io7m.jvvfs.PathVirtual)">createDirectory</s:link-external>
       	function, if no currently mounted archive provides the desired
       	mount point. Manually created directories are purely virtual constructs;
        creating a directory via the <s:term type="package">jvvfs</s:term>
        API does not modify the real OS filesystem or any archives.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Creating a directory</s:formal-item-title>
        <s:verbatim><![CDATA[
// If "archive1.zip" contains "/a/b/file.txt", then "archive2.zip" could, for
// example, be mounted at "/a" or "/a/b".
fs.mount("archive1.zip", PathVirtual.ROOT);
assert fs.isDirectory(PathVirtual.ofString("/a"));
assert fs.isDirectory(PathVirtual.ofString("/a/b"));
fs.mount("archive2.zip", PathVirtual.ofString("/a"));

// Explicitly creating "/c" and mounting "archive2.zip" there is also a possibility.
fs.createDirectory(PathVirtual.ofString("/c"));
assert fs.isDirectory(PathVirtual.ofString("/c"));
fs.mount("archive2.zip", PathVirtual.ofString("/c"));

// Assuming "/xyz/file.txt" exists in "archive2.zip", both of the following will work:
final InputStream s0 = fs.openFile("/a/xyz/file.txt");
final InputStream s1 = fs.openFile("/c/xyz/file.txt");]]>
        </s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The virtual filesystem presented by the
        <s:term type="package">jvvfs</s:term> package supports a subset
        of the usual filesystem operations: directories may be listed, files
        have modification dates and sizes.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>The Jvvfs Shell</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
      	The <s:term type="package">jvvfs</s:term> package includes a simple
      	command-line shell program for manipulating and exploring
      	<s:term type="package">jvvfs</s:term> filesystems.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Design And Implementation</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
      	This section attempts to document the design and implementation of
      	the <s:term type="package">jvvfs</s:term> filesystem.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Rationale</s:part-title>
    <s:part-contents/>

    <s:section>
      <s:section-title>Why not Java resources?</s:section-title>
      <s:paragraph>
        Java resources allow developers to access program resources and
        data files without explicit access to a filesystem. This is usually
        sufficient if all the resources in question are conceptually part of
        the program. The main problem that <s:term type="package">jvvfs</s:term>
        attempts to solve is the problem of the set of required resources not
        being known or available on program startup.
      </s:paragraph>
      <s:paragraph>
        Consider a game or simulation that allows the loading of third-party
        levels or other assets. The <s:link-external target="http://openttd.org">OpenTTD</s:link-external>
        engine is a good example of this, as it comes with a built-in installer
        for third party content:
      </s:paragraph>
      <s:formal-item kind="illustration">
        <s:formal-item-title>OpenTTD content installer</s:formal-item-title>
        <s:image source="openttd_content.png">OpenTTD content installer</s:image>
      </s:formal-item>
      <s:paragraph>
        Implementing the above with Java resources turns out to be rather
        complicated. Overriding resources (to allow for content "upgrades")
        is equally difficult.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="package">jvvfs</s:term> package provides a uniform
        namespace for all resources, and new resources can be added at any time
        by simply adding new archives and/or directories to the
        <s:term type="term">archive directory</s:term> and then mounting them
        as explained elsewhere in this documentation. The actual downloading of
        external resource archives is considered to be outside of the scope of
        <s:term type="package">jvvfs</s:term> and can be easily provided by
        classes in the Java standard library.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
